"""
GAME ENGINE √ó OPERATING SYSTEM SIMULATION
-----------------------------------------
This program demonstrates how OS concepts like:
 - CPU Scheduling (Round Robin)
 - Multithreading
 - Memory Management
 - Game Loop
are used in modern Game Engines.

Compatible with all online compilers (GDB, Replit, Programiz, etc.)
Author: Your Name
Date: 2025-11-13
"""

import threading
import time
import random
import queue

# ----------------------------------------------------------
# 1Ô∏è‚É£ Game Task (Simulating an Engine Subsystem)
# ----------------------------------------------------------

class GameTask:
    """
    Represents a subsystem in the game engine such as:
    Rendering, Physics, AI, or Audio.
    """
    def __init__(self, name, total_time):
        self.name = name
        self.remaining_time = total_time

    def execute(self, time_slice):
        """
        Simulates the task running for one time slice.
        """
        if self.remaining_time <= 0:
            return True  # already done

        run_time = min(self.remaining_time, time_slice)
        print(f"‚öôÔ∏è  {self.name} running for {run_time:.2f}s...")
        time.sleep(run_time * 0.3)  # simulate workload (scaled)
        self.remaining_time -= run_time

        if self.remaining_time <= 0:
            print(f"‚úÖ {self.name} completed!\n")
            return True
        else:
            print(f"‚è∏ {self.name} paused with {self.remaining_time:.2f}s remaining.\n")
            return False


# ----------------------------------------------------------
# 2Ô∏è‚É£ CPU Scheduler (Round Robin Simulation)
# ----------------------------------------------------------

def cpu_scheduler(task_queue, time_slice=1.0):
    """
    Simulates a Round-Robin CPU scheduler for Game Engine threads.
    """
    print("\nüß† CPU Scheduler: Starting Round-Robin Scheduling\n")

    while not task_queue.empty():
        task = task_queue.get()
        finished = task.execute(time_slice)

        if not finished:
            # Task still has work remaining ‚Üí requeue
            task_queue.put(task)

        time.sleep(0.3)

    print("‚úÖ All Engine Tasks Completed!\n")


# ----------------------------------------------------------
# 3Ô∏è‚É£ Memory Manager Simulation
# ----------------------------------------------------------

def memory_manager():
    """
    Simulates memory usage and cleanup inside a Game Engine.
    """
    print("\nüíæ Memory Management System\n")
    total_memory = 4096  # MB
    used_memory = random.randint(1000, 2000)

    for frame in range(1, 6):
        fluctuation = random.randint(-200, 300)
        used_memory = max(800, min(total_memory, used_memory + fluctuation))
        print(f"Frame {frame}: Used {used_memory} MB | Free {total_memory - used_memory} MB")
        time.sleep(0.5)

    print("‚ôªÔ∏è  Garbage Collector freed unused textures and meshes.\n")


# ----------------------------------------------------------
# 4Ô∏è‚É£ Game Loop Simulation
# ----------------------------------------------------------

def game_loop():
    """
    Simulates a simplified 60 FPS game loop updating multiple systems.
    """
    print("\nüéÆ GAME LOOP (60 FPS Target)\n")
    fps = 60
    frame_time = 1 / fps

    for frame in range(1, 11):
        print(f"üåÄ Frame {frame}: Updating Render | Physics | AI | Audio")
        time.sleep(frame_time * random.uniform(2, 4))

    print("\nüèÅ Game Loop Finished - 10 Frames Simulated.\n")


# ----------------------------------------------------------
# 5Ô∏è‚É£ Main Simulation Driver
# ----------------------------------------------------------

def main():
    print("=" * 60)
    print("üß© GAME ENGINE √ó OPERATING SYSTEM SIMULATION üß©")
    print("=" * 60)

    # Step 1: Initialize Engine Tasks (like threads)
    tasks = [
        GameTask("Rendering Thread", random.uniform(2.0, 3.0)),
        GameTask("Physics Engine", random.uniform(1.5, 2.5)),
        GameTask("AI System", random.uniform(1.0, 2.0)),
        GameTask("Audio Manager", random.uniform(0.5, 1.5))
    ]

    # Step 2: Load Tasks into a Queue for Scheduling
    task_queue = queue.Queue()
    for task in tasks:
        task_queue.put(task)

    # Step 3: Simulate Memory Management
    memory_manager()

    # Step 4: Simulate CPU Scheduling
    cpu_scheduler(task_queue)

    # Step 5: Run the Game Loop
    game_loop()

    print("üéØ Simulation Complete ‚Äì Game Engine and OS in Action!")
    print("=" * 60)


if __name__ == "__main__":
    main()
